function [evmInfo,eqSym,refSym] = hNRPDSCHEVM(waveConfig,rxWaveform,cfg)
%hNRPDSCHEVM EVM calculation
%   [EVMINFO,EQSYM,REFSYM] = hNRPDSCHEVM(WAVECONFIG,RXWAVEFORM,CFG)
%   Calculates the error vector magnitude (EVM) of a received waveform. If
%   cfg.EVM3GPP is true, EVM measurement is done using the 3GPP specified
%   EVM algorithm as defined in TS 38.104, Annex B(FR1) / Annex C(FR2)
%
%   EVMINFO is a structure containing EVM statistics with fields:
%   SubcarrierRMS      - RMS EVM per subcarrier
%                        (Column vector of N subcarriers)
%   SubcarrierPeak     - Peak EVM per subcarrier
%                        (Column vector of N subcarriers)
%   SymbolRMS          - RMS EVM Per symbol
%                        (Column vector of S symbols)
%   SymbolPeak         - Peak EVM Per symbol
%                        (Column vector of S symbols)
%   SlotRMS            - RMS EVM per slot
%                        (Column vector of x slots)
%   SlotPeak           - Peak EVM Per slot
%                        (Column vector of x slots)
%   EVMGrid            - Raw error vector for the selected window edge
%                        (N subcarriers x Symbols)
%   OverallEVM         - structure containing EVM statistics for the
%                        overall waveform. It contains these fields:
%       EV             - Raw error vector for the overall waveform
%                        (Array of 1 x n layers)
%       RMS            - RMS EVM for the overall waveform
%                        (Scalar)
%       Peak           - Peak EVM for the overall waveform
%                        (Scalar)
%   EQSYM              - Output cell array of IQ constellations for low &
%                        high EVM window locations
%                        (2 x Number of Slots)
%   REFSYM             - Output cell array of reference IQ constellations
%                        for low and high EVM window locations. 
%                        (2 x Number of Slots)
%   WAVECONFIG         - Input object of type 'nrDLCarrierConfig'
%
%   RXWAVEFORM         - Time domain baseband IQ samples input. Timing of
%                        the waveform is assumed to be slot-wise aligned
%                        with sample level fine-tuning performed
%                        subsequently. The length of the waveform can be an
%                        arbitrary number of slots
%   CFG is a structure with the fields:
%   Evm3GPP            - Enables or disables 3GPP method of EVM computation
%                        (Default value : false)
%   TargetRNTIs        - Contains the list of target RNTIs to decode. If
%                        not specified, the list is autogenerated as
%                        specified in the standard
%                        (Default value : Empty)
%   PlotEVM            - Enables or disables plotting of EVM (per slot, per
%                        symbol, per subcarrier and overall EVM)
%                        (Default value : true)
%   DisplayEVM         - Enables or disables the display of
%                        EVM statistics on the command window 
%                        (Default value : true)
%   Label              - A character vector or a string scalar indicating
%                        the name of NR-TM or FRC. It is used to extract
%                        the NR-TM/FRC label
%   InitialNSlot       - Starting slot of the input waveform
%                        (Default value : 0)
%   SampleRate         - Waveform sample rate. It is specified as either a
%                        positive scalar or []

% Copyright 2020-2021 The MathWorks, Inc.

    narginchk(3,3);
    if ~isfield(cfg,'Evm3GPP')
        evm3GPP = false;
    else
        evm3GPP = cfg.Evm3GPP;
    end
    if ~isfield(cfg,'TargetRNTIs')
        targetRNTIs = [];
    else
        targetRNTIs = cfg.TargetRNTIs;
    end
    if ~isfield(cfg,'PlotEVM')
        plotEVM = true;
    else
        plotEVM = cfg.PlotEVM;
    end
    if ~isfield(cfg,'DisplayEVM')
        displayEVM = true;
    else
        displayEVM = cfg.DisplayEVM;
    end
    if ~isfield(cfg,'Label')
        label = '';
    else
        label = cfg.Label;
    end
    if ~isfield(cfg,'InitialNSlot')
        initialNSlot = 0;
    else
        initialNSlot = cfg.InitialNSlot;
    end
    if ~isfield(cfg,'SampleRate')
        sampleRate = [];
    else
        sampleRate = cfg.SampleRate;
    end

    % Derive per-slot PDSCH resources (waveformResources) used as reference for EVM calculation
    [~,winfo] = nrWaveformGenerator(waveConfig);
    waveformResources = winfo.WaveformResources;
    waveformResources.Label = label;

    % Extract PDSCH allocation and carrier related information from waveConfig
    [pdschArray,~,carrier] = hListTargetPDSCHs(waveConfig,waveformResources,targetRNTIs);

    % Display error messages for the below checks for pdschArray.
    % Ensure modulation is same across the valid RNTI set
    % Atleast one non-empty resource field should be present
    % pdschArray should have atleast one non-empty DMRS resources
    % Atleast one PDSCH Configuration should be enabled
    pdschConfigLen = length(pdschArray);
    resourceEmptyCount = 0;
    dmrsEmptyCount = 0;
    pdschDisabledCount = 0;
    stopEVMProcessingFlag = false;

    % Extract bandwidth part related configuration
    if length(waveConfig.BandwidthParts) > 1
        warning('Multiple bandwidth parts not supported');
        stopEVMProcessingFlag = true;
    end
    bwpCfg = waveConfig.BandwidthParts{1,1};
    
    % Check carrier grid dimensions
    if carrier.NStartGrid > 0
        warning('Carrier grid must start with zero RB offset');
        stopEVMProcessingFlag = true;
    end

    for idx = 1:pdschConfigLen
        if idx > 1 && ~strcmp(pdschArray(idx-1).PDSCH.Modulation,pdschArray(idx).PDSCH.Modulation)
            error('All RNTIs must have the same modulation.');
        end
        if isempty(pdschArray(idx).Resources)
            resourceEmptyCount = resourceEmptyCount + 1;
        end
        nonEmptyCount = 0;
        for rIdx = 1:length(pdschArray(idx).Resources)
            if ~isempty(pdschArray(idx).Resources(rIdx).DMRSSymbols)
                nonEmptyCount = nonEmptyCount + 1;
            end
        end
        if nonEmptyCount == 0
            dmrsEmptyCount = dmrsEmptyCount + 1;
        end
        if ~pdschArray(idx).PDSCH.Enable
            pdschDisabledCount = pdschDisabledCount + 1;
        end
    end
    if resourceEmptyCount == pdschConfigLen
        warning('Input configuration does not contain adequate resources to proceed with EVM measurement');
        stopEVMProcessingFlag = true;
    end
    if dmrsEmptyCount == pdschConfigLen
        warning('Input configuration does not contain DMRS resources to proceed with EVM measurement');
        stopEVMProcessingFlag = true;
    end
    if pdschDisabledCount == pdschConfigLen
        warning('Input configuration does not valid PDSCH resources to proceed with EVM measurement');
        stopEVMProcessingFlag = true;
    end

    % Return since we cannot proceed due to unexpected configuration
    if stopEVMProcessingFlag
        evmInfo.SubcarrierRMS = [];
        evmInfo.SubcarrierPeak = [];
        evmInfo.SymbolRMS = [];
        evmInfo.SymbolPeak = [];
        evmInfo.SlotRMS = [];
        evmInfo.SlotPeak = [];
        evmInfo.EVMGrid = [];
        evmInfo.OverallEVM.EV = [];
        evmInfo.OverallEVM.RMS = [];
        evmInfo.OverallEVM.Peak = [];
        eqSym = [];
        refSym = [];
        return;
    end

    % Obtain OFDM related info
    carrier.NSlot = initialNSlot;
    ofdmInfo = nrOFDMInfo(carrier);
    if isempty(sampleRate)
        ofdmInfo.SamplesPerSubframe = sum(ofdmInfo.SymbolLengths);
    else
        ofdmInfo.SamplesPerSubframe = sampleRate/1000;
    end

    % Generate a reference grid of length two frames for timing synchronization
    refGrid = referenceGrid(carrier,bwpCfg,pdschArray,ofdmInfo.SlotsPerFrame*2);

    % Time synchronization of input waveform
    offset = nrTimingEstimate(carrier,rxWaveform,refGrid,'SampleRate',sampleRate);
    rxWaveform = rxWaveform(1+offset:end,:);

    % Calculate overSamplingFactor if cfg.SampleRate is non-empty
    if isempty(sampleRate)
        overSamplingFactor = 1;
    else
        overSamplingFactor = sampleRate/sum(ofdmInfo.SymbolLengths)/1000;
    end

    % Calculate number of subframes, slots and frames
    % Slot samples length may vary in a given waveform for some Subcarrier
    % spacings. remSfSamples and remSlot are used to account for this
    % variation.
    remSfSamples = mod(size(rxWaveform, 1),ofdmInfo.SamplesPerSubframe);
    remSlot = 0;
    remSfSamples = floor(remSfSamples/overSamplingFactor);
    if remSfSamples
        remSlot = floor(remSfSamples/sum(ofdmInfo.SymbolLengths(1:1:ofdmInfo.SymbolsPerSlot)));
    end
    nSubframes = floor(size(rxWaveform, 1)/ofdmInfo.SamplesPerSubframe);
    nSlots = nSubframes*ofdmInfo.SlotsPerSubframe+ remSlot;
    nFrames = floor(nSlots/(10*ofdmInfo.SlotsPerSubframe));
    L = ofdmInfo.SymbolsPerSlot;
    nLayers = pdschArray(1).PDSCH.NumLayers;

    % Generate a reference grid for slots corresponding to the length of
    % the input waveform. This grid contains only the DM-RS and is
    % primarily used for channel estimation
    refGrid = referenceGrid(carrier,bwpCfg,pdschArray,nSlots);

    % Slot allocation of the PDSCH configurations may overlap with each
    % other. Extract unique allocated slots
    activeSlots = [];
    for pIdx = 1:pdschConfigLen
        if ~isempty(pdschArray(pIdx).Resources)
            activeSlots = [activeSlots pdschArray(pIdx).Resources.NSlot]; %#ok<*AGROW>
        end
    end
    activeSlots = unique(activeSlots);

    % number of FFT Locations in each CP, based on EVM mode (Standard / 3GPP)
    nEVMWindowLocations = 1;
    if evm3GPP
        nEVMWindowLocations = 2;
    end

    % Resize refGrid based on BWP dimensions
    refGrid = refGrid(12*bwpCfg.NStartBWP+1:12*(bwpCfg.NStartBWP+bwpCfg.NSizeBWP),:,:);

    % Declare storage variables
    eqSym = cell(2,1);                  % Equalized symbols for constellation plot, for low/high EVM window locations
    refSym = cell(2,1);                 % Reference symbols for constellation plot, for low/high EVM window locations
    refSlotGrid = zeros(size(refGrid,1),nSlots*L,size(refGrid,3),nEVMWindowLocations);   % 4-D Grid of reference IQs
    eqSlotGrid = zeros(size(refGrid,1),nSlots*L,size(refGrid,3),nEVMWindowLocations);    % 4-D Grid of equalized IQs
    rxGridLow = [];                     % Demodulated OFDM grid, for 1st CP position
    rxGridHigh = [];                    % Demodulated OFDM grid, for 2nd CP position
    HestLow = [];                       % Channel estimation for 1st CP position
    HestHigh = [];                      % Channel estimation for 2nd CP position

    % Restrict CP length as per TS 38.104, Annex B.5.1 (FR1) / Annex C.5.1 (FR2)
    cpLength = double(ofdmInfo.CyclicPrefixLengths(2));
    L = carrier.SymbolsPerSlot;

    % Populate pdschObj of type 'nrPDSCHConfig'. It is to be used for
    % Common Phase error (CPE) estimation and decoding PDSCH
    pdschObj = extractPdschCfg(pdschArray);
    for idx = 1:pdschConfigLen
        pdschObj{idx}.NStartBWP = waveConfig.BandwidthParts{1,1}.NStartBWP;
        pdschObj{idx}.NSizeBWP  = waveConfig.BandwidthParts{1,1}.NSizeBWP;
        if isempty(pdschObj{idx}.NID)
            pdschObj{idx}.NID = carrier.NCellID;
        end
    end

    % If the waveform contains an encoded transport block, generate
    % reference paramters needed for decoding and re-encoding.
    % The re-encoded IQ samples are used as a reference for EVM calculation.
    % A single PDSCH config is assumed for processing here
    pdschEncodingOn = waveConfig.PDSCH{1}.Coding;
    if pdschEncodingOn
        pdsch = pdschArray(1).PDSCH;
        if isempty(pdsch.NID)
            pdschObj{1}.NID = carrier.NCellID;
        end
        nLayers = pdsch.NumLayers;
        decodeDLSCH = nrDLSCHDecoder;
        decodeDLSCH.TargetCodeRate = pdsch.TargetCodeRate;
        decodeDLSCH.LDPCDecodingAlgorithm = 'Normalized min-sum';
        dlsch = nrDLSCH('MultipleHARQProcesses',false);
    end

    frameEVM = repmat(hRawEVM([]), 1, max(nFrames,1));

    % When evm3GPP is true, two EVM window locations and two CP fractions
    % are selected for 3GPP EVM for OFDM demodulation. If false, a single
    % EVM window location is used, which is centred in the middle of the CP
    if evm3GPP
        W = getEVMWindow(carrier,waveConfig.FrequencyRange,waveConfig.ChannelBandwidth,ofdmInfo.Nfft);
        nEVMWindowLocations = 2;
        cpFraction = [0 ; W/cpLength];
    else
        nEVMWindowLocations = 1;
        cpFraction = 0.5;      % Use default value
    end

    % For some subcarrier spacing configurations, some slots will have more
    % samples than others. Keep track of current slot position in terms of
    % samples using prevSlotSampleCount and slotIdxInSf
    prevSlotSampleCount = 0;

    for slotIdx = 0:nSlots-1
        slotIdxInSf = mod(slotIdx + initialNSlot,ofdmInfo.SlotsPerSubframe);
        samplesInSlot = sum(ofdmInfo.SymbolLengths(slotIdxInSf*ofdmInfo.SymbolsPerSlot+ (1:ofdmInfo.SymbolsPerSlot)));
        samplesInSlot = samplesInSlot*overSamplingFactor;
        rxSlot = rxWaveform(prevSlotSampleCount+(1:(samplesInSlot)),:);
        prevSlotSampleCount = prevSlotSampleCount + samplesInSlot;
        rxGridLow = [rxGridLow nrOFDMDemodulate(carrier, rxSlot, 'CyclicPrefixFraction',cpFraction(1),'SampleRate',sampleRate)];
        if nEVMWindowLocations == 2
            rxGridHigh = [rxGridHigh nrOFDMDemodulate(carrier, rxSlot, 'CyclicPrefixFraction',cpFraction(2),'SampleRate',sampleRate)];
        end
        carrier.NSlot = carrier.NSlot + 1;
    end

     % Work only on the relevant BWP in the waveform to simplify indexing
     rxGridLow = rxGridLow(12*bwpCfg.NStartBWP+1:12*(bwpCfg.NStartBWP+bwpCfg.NSizeBWP),:,:);
     if evm3GPP
         rxGridHigh = rxGridHigh(12*bwpCfg.NStartBWP+1:12*(bwpCfg.NStartBWP+bwpCfg.NSizeBWP),:,:);
     end

    % For 3GPP EVM processing, extract IQ samples in blocks of 10 ms each (TS 38.104, Annex B.6/C.6)
    nSlots10Ms = min(nSlots,10*carrier.SubcarrierSpacing/15);
    nBlocks = ceil(nSlots/nSlots10Ms);                  % Each block is 10 ms in length, can go upto 2 for TDD FRC
    if evm3GPP
        % For each 10 ms block, estimate the channel coefficients
        for blkIdx = 0:(nBlocks-1)
            % Index of symbols within current block. If a symbol index
            % exceeds the length of the received grid remove it
            symIdx = blkIdx*L*nSlots10Ms+(1:(L*nSlots10Ms));
            symIdx(symIdx>size(rxGridLow, 2)) = [];
            HestLowBlk = hChannelEstimateEVM3GPP(rxGridLow(:, symIdx, :),refGrid(:, symIdx,:),'movingAvgFilter','CDMLengths',pdschArray(1).CDMLengths);
            HestHighBlk = hChannelEstimateEVM3GPP(rxGridHigh(:, symIdx, :),refGrid(:, symIdx,:),'movingAvgFilter','CDMLengths',pdschArray(1).CDMLengths);
            HestLow = [HestLow HestLowBlk];
            HestHigh = [HestHigh HestHighBlk];
        end
    else
        % Compute channel estimates for each slot
        for slotIdx = 1:nSlots
            symIdx = (slotIdx-1)*L+1:slotIdx*L;
            symIdx(symIdx>size(rxGridLow, 2)) = [];
            HestLowBlk = nrChannelEstimate(rxGridLow(:, symIdx, :),refGrid(:, symIdx,:),'CDMLengths',pdschArray(1).CDMLengths);
            HestLow = [HestLow HestLowBlk];
        end
    end
    
    numSCs = size(rxGridLow,1);
    % PDSCH REs may not always be present on the same set of RBs as DMRS.
    % For each such slot, extrapolate the channel coefficients to span the
    % location of these PDSCH allocation regions

    % Ensure slot has channel coefficients for the corresponding PDSCH
    % allocation
    for slotIdx = 1:nSlots
        symIdx = (slotIdx-1)*L+1:slotIdx*L;
        symIdx(symIdx>size(rxGridLow, 2)) = [];

        % Locate RBs where channel coefficients are present
        [row ,~]= find(HestLow(:,symIdx));
        row = unique(row);
        HestRb = unique(floor((row-1)/12));
        rxRb = [];
        for idx = 1:length(pdschArray)
            if any(pdschArray(idx).PDSCH.SlotAllocation == slotIdx-1)
            rxRb = [rxRb pdschArray(idx).PDSCH.PRBSet];
            end
        end

        % Set extrapolateHest to true if allocated RB list does not match
        % list of RBs containing channel coefficients
        extrapolateHest = false;
        for rbIdx = 1:length(rxRb)
            if ~any(HestRb == rxRb(rbIdx))
                extrapolateHest = true;
                break;
            end
        end

        % Process only for slots where PDSCH RBs do not contain channel
        % estimates. Extrapolate the channel coefficients over the slot
        % span. The first entry in the pdschArray is sufficient for this
        % purpose
        if extrapolateHest && ~isempty(HestRb)
            firstDmrsLocInSlot = pdschArray(1).PDSCH.DMRS.DMRSSubcarrierLocations(1)+1;
            
            R = size(HestLow,3);
            P = size(HestLow,4);
            for p = 1:P
                for r = 1:R
                    H_tmp = HestLow(:,symIdx(firstDmrsLocInSlot),r,p);
                    if sum(abs(H_tmp)) == 0
                        interpEqCoeff = 1e-16.*ones(size(H_tmp,1),1);
                    else
                        interpEqCoeff = interp1(find(H_tmp~=0),H_tmp(H_tmp~=0),(1:numSCs).','linear','extrap');
                    end
                    interpEqCoeff = repmat(interpEqCoeff,1,L);
                    HestLow(:,symIdx,r,p) = interpEqCoeff;
                end
            end
        end
    end

    % In case of non-3GPP case, only a single EVM grid is used.
    % Compute the DL EVM for each active/valid DL slot, store the results
    % in a cell-array for later processing. Skip slots which are not DL.
    slotRange = activeSlots(activeSlots < (initialNSlot+nSlots));
    slotRange = slotRange(slotRange >= initialNSlot);
    if isempty(slotRange)
        slotRange = [];
        plotEVM = false;
        warning('No scheduled slots found for EVM processing.');
    end
    
    % Iterate for each active slot
    for slotIdx=slotRange
        carrier.NSlot = slotIdx;
        [pdschIndices,refSymbols,ptrsIndices,ptrsSymbols] = hSlotResources(pdschArray,slotIdx);

        % Do not include first two slot symbols for PDSCH EVM (used for
        % control as specified in TS 38.141-1 table 4.9.2.2-2 (NR-TMs) / 
        % TS 38.101-1 table A.3.1-1 (FRCs))
        % This step is not performed when extrapolateHest is true or label
        % is absent.
        % Ensure that the symbol allocation does not include the first two
        % symbols when the 'label' field is set
        if ~isempty(label) && ~extrapolateHest
            idx = pdschIndices(:,1) <= (2*numSCs);
            pdschIndices(idx,:) = [];
            refSymbols(idx,:) = [];
        end

        % Extract the relevant slot, channel estimates and PDSCH allocated REs
        currentSlotIdx = slotIdx - initialNSlot;
        currentRxGridLow = rxGridLow(:, currentSlotIdx*L+(1:L), :);
        currentHestLow = HestLow(:, currentSlotIdx*L+(1:L),:,:);
        [pdschRxLow,pdschHestLow] = nrExtractResources(pdschIndices,currentRxGridLow,currentHestLow);
        noiseEst = 0;           % ZF based equalization, as per TS 38.104, Annex B.1 (FR1) / Annex C.1 (FR2)
        [eqGridLow,csiLow] = nrEqualizeMMSE(pdschRxLow,pdschHestLow,noiseEst);
        if evm3GPP
            currentRxGridHigh = rxGridHigh(:, currentSlotIdx*L+(1:L), :);
            currentHestHigh = HestHigh(:, currentSlotIdx*L+(1:L),:,:);
            [pdschRxHigh,pdschHestHigh] = nrExtractResources(pdschIndices,currentRxGridHigh,currentHestHigh);
            [eqGridHigh,csiHigh] = nrEqualizeMMSE(pdschRxHigh,pdschHestHigh,noiseEst);
        end
        
       % Estimate and compensate phase error
        if pdschArray(1).PDSCH.EnablePTRS
            eqGridLow = [];
            eqGridHigh = [];
            % Process only active configurations, one per slot. If more
            % than one configuration is present, process the first one as
            % the indices( pdschIndices,dmrsIndices) collectively include
            % all active ones in current slot
            for idx = 1:length(pdschObj)
                if any(mod(currentSlotIdx,pdschArray(idx).PDSCH.Period) == pdschArray(idx).PDSCH.SlotAllocation)
                    eqGridLow = [eqGridLow; pdschCPE(carrier,pdschObj{idx},pdschIndices,ptrsIndices,ptrsSymbols,currentRxGridLow,currentHestLow)];
                    if evm3GPP
                        eqGridHigh = [eqGridHigh; pdschCPE(carrier,pdschObj{idx},pdschIndices,ptrsIndices,ptrsSymbols,currentRxGridHigh,currentHestHigh)];
                    end
                    break;
                end
            end
        end

        % Accumulate equalized IQs
        eqSym{1} = [eqSym{1}; eqGridLow];
        if evm3GPP
            eqSym{2} = [eqSym{2}; eqGridHigh];
        end

        % Create vectors needed for decoding each pdschObj when 'Coding' is
        % enabled
        if pdschEncodingOn
            trBlkSizes = [];
            G = [];
            for pIdx = 1:pdschConfigLen
                if any(mod(currentSlotIdx,pdschArray(pIdx).PDSCH.Period) == pdschArray(pIdx).PDSCH.SlotAllocation)
                    currentSlotRange = [];
                    currentSlotRange = [currentSlotRange pdschArray(pIdx).Resources.NSlot];
                    resourceIdx = find(currentSlotIdx == currentSlotRange);
                    trBlkSizes = [trBlkSizes;pdschArray(pIdx).Resources(resourceIdx).TransportBlockSize];
                    G = [G;pdschArray(pIdx).Resources(resourceIdx).G];
                end
            end
        end

        % For low edge EVM and high edge EVM
        for e = 1:nEVMWindowLocations
            % Select the low or high edge equalizer output
            if (e == 1)
                eqGrid = eqGridLow;
                csi = csiLow;
            else
                eqGrid = eqGridHigh;
                csi = csiHigh;
            end
            if ~pdschEncodingOn || ~any(trBlkSizes)
                rxSymbols = eqGrid;
            else
                refSymbols = [];
                eqOffset = 0;
                rx = cell(1);
                tbIdx = 1;
                for pIdx = 1:pdschConfigLen
                    % Decode rxSymbols. If CRC passes, re-encode them for
                    % obtaining reference IQs for EVM calculation Extract
                    % the equalized symbols and csi for each pdschObj
                    if ~any(mod(currentSlotIdx,pdschArray(pIdx).PDSCH.Period) == pdschArray(pIdx).PDSCH.SlotAllocation)
                        continue;
                    end
                    eqLen = length(pdschArray(pIdx).Resources(resourceIdx).ChannelIndices);
                    eq = eqGrid(1+eqOffset:eqOffset+eqLen,:);
                    currentCsi = csi(1+eqOffset:eqOffset+eqLen,:);
                    eqOffset = eqOffset+ eqLen;
                    [dlschLLRs,rxSymbols] = nrPDSCHDecode(eq,pdschObj{pIdx}.Modulation,pdschObj{pIdx}.NID,pdschObj{pIdx}.RNTI,noiseEst);
                    rx{1} = [rx{1} ; rxSymbols{1}];

                    % Scale LLRs by CSI
                    numCWs = size(dlschLLRs,2);
                    currentCsi = nrLayerDemap(currentCsi);    % CSI layer demapping
                    for cwIdx = 1:numCWs
                        Qm = length(dlschLLRs{cwIdx})/length(rxSymbols{cwIdx}); % bits per symbol
                        currentCsi{cwIdx} = repmat(currentCsi{cwIdx}.',Qm,1);   % expand by each bit per symbol
                        dlschLLRs{cwIdx} = dlschLLRs{cwIdx} .* currentCsi{cwIdx}(:);   % scale
                    end
                    decodeDLSCH.TransportBlockLength = trBlkSizes(tbIdx);
                    decodeDLSCH.TargetCodeRate = pdschArray(pIdx).PDSCH.TargetCodeRate;
                    [demodBits,blkerr] = decodeDLSCH(dlschLLRs,pdschObj{pIdx}.Modulation,nLayers,waveConfig.PDSCH{pIdx}.RVSequence(1));
                    if any(blkerr)
                        warning('CRC failed on decoded data, using sliced received symbols, EVM may be inaccurate.');
                        % Attempt to gracefully handle bad CRC. Generate some
                        % bits for this slot by hard slicing LLRs, so that the
                        % simulation can continue
                        recodedBits = cellfun(@(x) x<0, dlschLLRs, 'UniformOutput', false);
                    else
                        trBlk = demodBits;
                        dlsch.TargetCodeRate = decodeDLSCH.TargetCodeRate;
                        setTransportBlock(dlsch,trBlk);
                        recodedBits = dlsch(pdschObj{pIdx}.Modulation,nLayers,G(tbIdx),waveConfig.PDSCH{pIdx}.RVSequence(1));
                    end
                    ref = nrPDSCH(recodedBits,pdschObj{pIdx}.Modulation,nLayers,pdschObj{pIdx}.NID,pdschObj{pIdx}.RNTI);
                    refSymbols = [refSymbols;ref];
                    tbIdx = tbIdx+1;
                end
            end
            if pdschEncodingOn && any(trBlkSizes)
                rxSymbols = cell2mat(rx);
            end

            % Handle slots containing reference symbols with different dimensions than others
            if size(refSym,1) == size(refSymbols,2)
                refSym{e} = [refSym{e}; refSymbols];
            else
                tmpRef = [refSymbols zeros(size(refSymbols,1),1)];
                refSym{e} = [refSym{e}; tmpRef];
            end

            % Map each reference-slot , equalized slot to it's correct position in grid, layer, EVM-edge
            rbsPerSlot = numSCs*carrier.SymbolsPerSlot;
            tmpGrid = zeros(numSCs,carrier.SymbolsPerSlot);
            if pdschEncodingOn && any(trBlkSizes)
                rxSymbols = reshape(rxSymbols,nLayers,length(rxSymbols)/nLayers).';
            end
            ind = zeros(size(pdschIndices,1),nLayers);
            for layerIdx = 1:nLayers
                if layerIdx <= size(pdschIndices,2)
                    ind(:,layerIdx) = pdschIndices(:,layerIdx) - rbsPerSlot*(layerIdx -1);
                    tmpGrid(ind(:,layerIdx)) = refSymbols(:,layerIdx);
                    symIdx = (slotIdx)*L+1:(slotIdx+1)*L;
                    refSlotGrid(:,symIdx,layerIdx,e) = tmpGrid;
                    tmpGrid(:) = 0;
                    tmpGrid(ind(:,layerIdx)) = rxSymbols(:,layerIdx);
                    eqSlotGrid(:,symIdx,layerIdx,e) = tmpGrid;
                    tmpGrid(:) = 0;
                end
            end
        end
    end

    % Evaluate detailed EVM statistics for a grid of equalized and reference slots
    evmInfo = hEVM(carrier,eqSlotGrid,refSlotGrid);
    evm = evmInfo.EVM;

    % Remove EVM field as it not part of the output
    evmInfo = rmfield(evmInfo,'EVM');

    % Display per slot, and per EVM edge EVM statistics
    for slotIdx  = slotRange
        for e = 1:nEVMWindowLocations
            if (e == 1)
                edge = 'Low edge';
                if nEVMWindowLocations == 1
                    edge = '';              % Print only single EVM per slot
                end
            else
                edge = 'High edge';
            end
            if displayEVM
                fprintf('%s RMS EVM, Peak EVM, slot %d: %0.3f %0.3f%%\n',edge,slotIdx,evm(e, slotIdx+1).RMS*100,evm(e, slotIdx+1).Peak*100);
            end
        end
    end

   printFrameAvg = 1;      % Ensures only fully occupied frames are printed
    % After we've filled a frame or if we're at the end of a signal
    % shorter than a frame, do EVM averaging
    if (nFrames == 0)
        nFrames = 1;     % Below loop needs to run atleast once
        printFrameAvg = 0; % Dont print low/high EVM as we dont have sufficient slots to fill up a frame
    end

    % 1-based indexing for accessing evm
    % Limit frame-averaging to complete frames only
    slotRange = slotRange+1;
    slotRange = slotRange(slotRange <= (nFrames*10*ofdmInfo.SlotsPerSubframe));

    % loop through each frame, selecting the frames with higher RMS( when
    % measuring 3GPP EVM)
    for frameIdx = 0:nFrames-1
        frameLowEVM = hRawEVM(cat(1,evm(1,slotRange).EV));
        frameEVM(frameIdx+1) = frameLowEVM;
        if evm3GPP
            frameHighEVM = hRawEVM(cat(1,evm(2,slotRange).EV));
            if frameHighEVM.RMS > frameLowEVM.RMS
                frameEVM(frameIdx+1) = frameHighEVM;
            end
        end
        if printFrameAvg && displayEVM
            if evm3GPP
                fprintf('Averaged low edge RMS EVM, frame %d: %0.3f%%\n',frameIdx,frameLowEVM.RMS*100);
                fprintf('Averaged high edge RMS EVM, frame %d: %0.3f%%\n',frameIdx,frameHighEVM.RMS*100);
            end
            fprintf('Averaged RMS EVM frame %d: %0.3f%%\n',frameIdx,frameEVM(frameIdx+1).RMS*100);
        end
    end

    if plotEVM
        % For each valid slot, update the plot (symbol,SC,slot,grid-wise)
        hEVMPlots(evmInfo,eqSym,refSym);
    end
    
    if displayEVM
        fprintf('Averaged overall RMS EVM: %0.3f%%\n', evmInfo.OverallEVM.RMS*100);
        disp("Overall Peak EVM = " + string((evmInfo.OverallEVM.Peak)*100) + "%");
    end
end

function W = getEVMWindow(carrier,frequencyRange,channelBandwidth,nFFT)
%   W = getEVMWindow(CARRIER,FREQUENCYRANGE,CHANNELBANDWIDTH,NFFT) is the
%   error vector magnitude window length, as mentioned in TS 38.104, Section
%   B.5.2 < FR1 /FR2 >. W is defined for a given combination of subcarrier
%   spacing, channel bandwidth/fft length, frequency range and CP type. W
%   is subsequently used as an intermediate value to decide the CP Fraction
%   for OFDM demodulation

    scsFR1 = [15 30 60];
    scsFR2 = [60 120];
    % BW MHz        5  10 15 20  25  30  40  50  60  70  80  90  100
    nfftFR1 = [256 384 512 768 1024 1536 2048 3072  4096];
    WsFR1   = [NaN NaN  14 NaN   28   44   58  108   144;      % NormalCp, 15kHz
                 8 NaN  14  22   28   54   72  130   172;      % NormalCp, 30kHz
                 8  11  14  26   36   64   86  NaN   NaN;      % NormalCp, 60kHz
                54  80 106 164  220  340  454  NaN   NaN];     % ExtendedCp, 60kHz

    % BW MHz        50 100 200 400
    nfftFR2 = [512 1024 2048 4096];
    WsFR2        = [NaN  36  72  144;                           % NormalCP, 60kHz
                    18   36  72  144;                          % NormalCP, 120kHz
                   NaN  220  440 880];                         % ExtendedCP, 60kHz
    W = []; %#ok<NASGU>
    if (strcmpi(frequencyRange,'FR1'))
        rowIdx = find(carrier.SubcarrierSpacing == scsFR1) + double(strcmpi(carrier.CyclicPrefix,'extended'));
        W = WsFR1(rowIdx,nFFT == nfftFR1);
        if channelBandwidth == 25
            if nFFT == 512 && carrier.SubcarrierSpacing == 60
                if strcmpi(carrier.CyclicPrefix,'extended')
                    W = 110;
                else
                    W = 18;
                end
            elseif nFFT == 1024 && carrier.SubcarrierSpacing == 30
                W = 36;
            elseif nFFT == 2048 && carrier.SubcarrierSpacing == 15
                W = 72;
            end
        end
    else
        rowIdx = find(carrier.SubcarrierSpacing == scsFR2) + double(strcmpi(carrier.CyclicPrefix,'extended'))*2;
        W = WsFR2(rowIdx,nFFT == nfftFR2);
    end
    % Filter out invalid combinations
    if isnan(W) || isempty(W)
        error('Invalid FFT/SCS/BW combination');
    end
end

function refGrid = referenceGrid(carrier,bwpCfg,pdschArray,nSlots)
    % Create a reference grid for the required number of slots
    % It contains the DM-RS symbols specified in pdschArray
    % Returns REFGRID of dimensions K-by-S-by-L, where K is number of
    % subcarriers of size carrier.NSizeGrid, S is the number of symbols
    % spanning nSlots and L is the number of layers

    nSubcarriers = carrier.NSizeGrid * 12;
    L = carrier.SymbolsPerSlot*nSlots; % Number of OFDM symbols in the reference grid
    nLayers = size(pdschArray(1).Resources(1).ChannelIndices,2);
    bwpStart = bwpCfg.NStartBWP;
    bwpLen = bwpCfg.NSizeBWP;
    refGrid = zeros(nSubcarriers,L,nLayers); % empty grid
    bwpGrid = zeros(bwpLen*12,L,nLayers);
    rbsPerSlot = bwpLen*12*carrier.SymbolsPerSlot;

    % Populate the DM-RS symbols in the reference grid for all slots
    % Place the bwpGrid in a carrier grid (at an appropriate
    % location) in case the BWP size is not the same as the carrier grid
    for slotIdx=carrier.NSlot+(0:nSlots-1)
        [~,~,dmrsIndices,dmrsSymbols] = hSlotResources(pdschArray,slotIdx);
        if ~isempty(dmrsIndices)
            for layerIdx = 1:nLayers
                if layerIdx <= size(dmrsIndices,2)
                    dmrsIndices(:,layerIdx) = dmrsIndices(:,layerIdx) - rbsPerSlot*(layerIdx -1)+ (L*bwpLen*12*(layerIdx-1));
                    bwpGrid(dmrsIndices(:,layerIdx)+(slotIdx-carrier.NSlot)*rbsPerSlot) = dmrsSymbols(:,layerIdx);
                end
            end
            refGrid(12*bwpStart+1:12*(bwpStart+bwpLen),:,:) = bwpGrid;
        end
    end
end

function [pdschObj] = extractPdschCfg(pdschWaveCfg)
    % Extract relevant parameters from waveform generator PDSCH struct to build an obj of type 'nrPDSCHConfig' 
    % Set PDSCH parameters
    pdschObj = {};
    for idx = 1:length(pdschWaveCfg)
        pdschObj{idx} = nrPDSCHConfig;
        pdsch = pdschWaveCfg(idx).PDSCH;
        pdschObj{idx}.PRBSet = pdsch.PRBSet;
        pdschObj{idx}.SymbolAllocation     = pdsch.SymbolAllocation;
        pdschObj{idx}.Modulation           = pdsch.Modulation;
        pdschObj{idx}.NumLayers            = pdsch.NumLayers;
        pdschObj{idx}.MappingType          = pdsch.MappingType;
        pdschObj{idx}.RNTI                 = pdsch.RNTI;
        pdschObj{idx}.NID                  = pdsch.NID;
        pdschObj{idx}.VRBToPRBInterleaving = pdsch.VRBToPRBInterleaving;
        pdschObj{idx}.VRBBundleSize        = pdsch.VRBBundleSize;

        for idx2 = 1:length(pdsch.ReservedPRB)
            pdschObj{idx}.ReservedPRB{idx2} = nrPDSCHReservedConfig;     
            pdschObj{idx}.ReservedPRB{idx2}.PRBSet    = pdsch.ReservedPRB{idx2}.PRBSet;
            pdschObj{idx}.ReservedPRB{idx2}.SymbolSet = pdsch.ReservedPRB{idx2}.SymbolSet;
            pdschObj{idx}.ReservedPRB{idx2}.Period    = pdsch.ReservedPRB{idx2}.Period;
        end

        dmrs{idx} = nrPDSCHDMRSConfig;
        dmrs{idx}.DMRSPortSet             = pdsch.DMRS.DMRSPortSet;
        dmrs{idx}.DMRSTypeAPosition       = pdsch.DMRS.DMRSTypeAPosition;
        dmrs{idx}.DMRSLength              = pdsch.DMRS.DMRSLength;
        dmrs{idx}.DMRSAdditionalPosition  = pdsch.DMRS.DMRSAdditionalPosition;
        dmrs{idx}.DMRSConfigurationType   = pdsch.DMRS.DMRSConfigurationType;
        dmrs{idx}.NumCDMGroupsWithoutData = pdsch.DMRS.NumCDMGroupsWithoutData;
        dmrs{idx}.NIDNSCID                = pdsch.DMRS.NIDNSCID;
        dmrs{idx}.NSCID                   = pdsch.DMRS.NSCID;
        pdschObj{idx}.DMRS = dmrs{idx};

        % Set PT-RS parameters
        ptrs{idx} = nrPDSCHPTRSConfig;
        pdschObj{idx}.EnablePTRS         = pdsch.EnablePTRS;
        ptrs{idx}.TimeDensity               = pdsch.PTRS.TimeDensity;
        ptrs{idx}.FrequencyDensity          = pdsch.PTRS.FrequencyDensity;
        ptrs{idx}.REOffset                  = pdsch.PTRS.REOffset;
        ptrs{idx}.PTRSPortSet               = pdsch.PTRS.PTRSPortSet;
        pdschObj{idx}.PTRS = ptrs{idx};
    end
end


function pdschEq = pdschCPE(carrier,pdsch,pdschIndices,ptrsIndices,ptrsSymbols,rxGrid,estChannelGrid)
%PDSCHEQ = pdschCPE(CARRIER,PDSCH,PDSCHINDICES,PTRSINDICES,PTRSSYMBOLS,RXGRID,ESTCHANNELGRID)
    % Slot-based Common phase error (CPE) estimation and correction for
    % PDSCH returns an equalized set of IQs, PDSCHEQ for which the CPE has
    % been estimated and compensated. PDSCHEQ is array spanning the length
    % of the PDSCH symbols x number of layers N. 
    % PDSCH is an obj of type 'nrPDSCHConfig'.
    % PDSCHINDICES is an array of S-by-L, where S is the
    % length of the PDSCH allocation and L is the number of layers.
    % PTRSINDICES is an array of S-by-L, where S is the length of the DMRS
    % allocation and L is the number of layers.
    % PTRSSYMBOLS is an array of S-by-L, where S is the length of the DMRS
    % allocation and L is the number of layers.
    % RXGRID is a N-by-S-by-L grid extracted from the OFDM demodulated
    % waveform. S is the number of symbols in a slot.
    % ESTCHANNELGRID is N-by-S-by-P-by-R grid. P is the number of antenna
    % ports
    
    [~,pdschIndicesInfo] = nrPDSCHIndices(carrier,pdsch);

    % Set noiseEst to zero as it was not estimated along with the
    % corresponding estChannelGrid
    noiseEst = 0;

    % Get PDSCH resource elements from the received grid
    [pdschRx,pdschHest] = nrExtractResources(pdschIndices,rxGrid,estChannelGrid);

    % Equalization
    pdschEq = nrEqualizeMMSE(pdschRx,pdschHest,noiseEst);

    % Initialize temporary grid to store equalized symbols
    tempGrid = nrResourceGrid(carrier,pdsch.NumLayers);

    % Extract PT-RS symbols from received grid and estimated
    % channel grid
    [ptrsRx,ptrsHest,~,~,~,ptrsLayerIndices] = nrExtractResources(ptrsIndices,rxGrid,estChannelGrid,tempGrid);

    % Equalize PT-RS symbols and map them to tempGrid
    ptrsEq = nrEqualizeMMSE(ptrsRx,ptrsHest,noiseEst);
    tempGrid(ptrsLayerIndices) = ptrsEq;

    % Estimate the residual channel at the PT-RS locations in
    % tempGrid
    cpe = nrChannelEstimate(tempGrid,ptrsIndices,ptrsSymbols,'CDMLengths',pdsch.DMRS.CDMLengths,'CyclicPrefix',carrier.CyclicPrefix);

    % Sum estimates across subcarriers, receive antennas, and
    % layers. Then, get the CPE by taking the angle of the
    % resultant sum
    cpe = angle(sum(cpe,[1 3 4]));

    % Map the equalized PDSCH symbols to tempGrid
    tempGrid(pdschIndices) = pdschEq;

    % Correct CPE in each OFDM symbol within the range of reference
    % PT-RS OFDM symbols
    if numel(pdschIndicesInfo.PTRSSymbolSet) > 0
        symLoc = pdschIndicesInfo.PTRSSymbolSet(1)+1:pdschIndicesInfo.PTRSSymbolSet(end)+1;
        tempGrid(:,symLoc,:) = tempGrid(:,symLoc,:).*exp(-1i*cpe(symLoc));
    end

    % Extract PDSCH symbols
    pdschEq = tempGrid(pdschIndices);
end